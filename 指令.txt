/**
@brief ：函数作用，是干嘛的
@param ：函数参数
@return ：函数返回值
@details ：分点换行概括函数的逻辑
*/
把下面的代码,按照上面的doxygen格式，添加函数头注释并汉化代码。要有函数作用，函数参数，函数返回值，分点换行概括函数的逻辑，给出完整代码

<<<<<<< Updated upstream
/** Read next PDO.
 */
void ec_fsm_pdo_read_action_next_pdo(
    ec_fsm_pdo_t *fsm,      /**< Finite state machine. */
    ec_datagram_t *datagram /**< Datagram to use. */
)
{
    if (fsm->pdo_pos <= fsm->pdo_count)
    {
        ecrt_sdo_request_index(&fsm->request, 0x1C10 + fsm->sync_index,
                               fsm->pdo_pos);
        ecrt_sdo_request_read(&fsm->request);
        fsm->state = ec_fsm_pdo_read_state_pdo;
        ec_fsm_coe_transfer(fsm->fsm_coe, fsm->slave, &fsm->request);
        ec_fsm_coe_exec(fsm->fsm_coe, datagram); // execute immediately
        return;
    }

    // finished reading PDO configuration

    ec_pdo_list_copy(&fsm->sync->pdos, &fsm->pdos);
    ec_pdo_list_clear_pdos(&fsm->pdos);

    // next sync manager
    ec_fsm_pdo_read_action_next_sync(fsm, datagram);
=======
/** Bring slave to OP.
 */
void ec_fsm_slave_config_enter_op(
    ec_fsm_slave_config_t *fsm, /**< slave state machine */
    ec_datagram_t *datagram     /**< Datagram to use. */
)
{
    // set state to OP
    fsm->state = ec_fsm_slave_config_state_op;
    ec_fsm_change_start(fsm->fsm_change, fsm->slave, EC_SLAVE_STATE_OP);
    ec_fsm_change_exec(fsm->fsm_change, datagram); // execute immediately
}

/*****************************************************************************/

/** Slave configuration state: OP
 */
void ec_fsm_slave_config_state_op(
    ec_fsm_slave_config_t *fsm, /**< slave state machine */
    ec_datagram_t *datagram     /**< Datagram to use. */
)
{
    ec_slave_t *slave = fsm->slave;

    if (ec_fsm_change_exec(fsm->fsm_change, datagram))
        return;

    if (!ec_fsm_change_success(fsm->fsm_change))
    {
        if (!fsm->fsm_change->spontaneous_change)
            slave->error_flag = 1;
        fsm->state = ec_fsm_slave_config_state_error;
        return;
    }

    // slave is now in OP

    EC_SLAVE_DBG(slave, 1, "Now in OP. Finished configuration.\n");

    fsm->state = ec_fsm_slave_config_state_end; // successful
>>>>>>> Stashed changes
}

/*****************************************************************************/

<<<<<<< Updated upstream
/** Fetch PDO information.
 */
void ec_fsm_pdo_read_state_pdo(
    ec_fsm_pdo_t *fsm,      /**< Finite state machine. */
    ec_datagram_t *datagram /**< Datagram to use. */
)
{
    if (ec_fsm_coe_exec(fsm->fsm_coe, datagram))
    {
        return;
    }

    if (!ec_fsm_coe_success(fsm->fsm_coe))
    {
        EC_SLAVE_ERR(fsm->slave, "Failed to read index of"
                                 " assigned PDO %u from SM%u.\n",
                     fsm->pdo_pos, fsm->sync_index);
        ec_fsm_pdo_read_action_next_sync(fsm, datagram);
        return;
    }

    if (fsm->request.data_size != sizeof(uint16_t))
    {
        EC_SLAVE_ERR(fsm->slave, "Invalid data size %zu returned"
                                 " when uploading SDO 0x%04X:%02X.\n",
                     fsm->request.data_size,
                     fsm->request.index, fsm->request.subindex);
        ec_fsm_pdo_read_action_next_sync(fsm, datagram);
        return;
    }

    if (!(fsm->pdo = (ec_pdo_t *)
              kmalloc(sizeof(ec_pdo_t), GFP_KERNEL)))
    {
        EC_SLAVE_ERR(fsm->slave, "Failed to allocate PDO.\n");
        ec_fsm_pdo_read_action_next_sync(fsm, datagram);
        return;
    }

    ec_pdo_init(fsm->pdo);
    fsm->pdo->index = EC_READ_U16(fsm->request.data);
    fsm->pdo->sync_index = fsm->sync_index;

    EC_SLAVE_DBG(fsm->slave, 1, "PDO 0x%04X.\n", fsm->pdo->index);

    list_add_tail(&fsm->pdo->list, &fsm->pdos.list);

    fsm->state = ec_fsm_pdo_read_state_pdo_entries;
    ec_fsm_pdo_entry_start_reading(&fsm->fsm_pdo_entry, fsm->slave, fsm->pdo);
    fsm->state(fsm, datagram); // execute immediately
=======
/** Reconfigure the slave starting at INIT.
 */
void ec_fsm_slave_config_reconfigure(
    ec_fsm_slave_config_t *fsm, /**< slave state machine */
    ec_datagram_t *datagram     /**< Datagram to use. */
)
{
    EC_SLAVE_DBG(fsm->slave, 1, "Slave configuration detached during "
                                "configuration. Reconfiguring.");

    ec_fsm_slave_config_enter_init(fsm, datagram); // reconfigure
}

/******************************************************************************
 *  Common state functions
 *****************************************************************************/

/** State: ERROR.
 */
void ec_fsm_slave_config_state_error(
    ec_fsm_slave_config_t *fsm, /**< slave state machine */
    ec_datagram_t *datagram     /**< Datagram to use. */
)
{
>>>>>>> Stashed changes
}

/*****************************************************************************/

<<<<<<< Updated upstream
/** Fetch PDO information.
 */
void ec_fsm_pdo_read_state_pdo_entries(
    ec_fsm_pdo_t *fsm,      /**< Finite state machine. */
    ec_datagram_t *datagram /**< Datagram to use. */
)
{
    if (ec_fsm_pdo_entry_exec(&fsm->fsm_pdo_entry, datagram))
    {
        return;
    }

    if (!ec_fsm_pdo_entry_success(&fsm->fsm_pdo_entry))
    {
        EC_SLAVE_ERR(fsm->slave, "Failed to read mapped PDO entries"
                                 " for PDO 0x%04X.\n",
                     fsm->pdo->index);
        ec_fsm_pdo_read_action_next_sync(fsm, datagram);
        return;
    }

    // next PDO
    fsm->pdo_pos++;
    ec_fsm_pdo_read_action_next_pdo(fsm, datagram);
}
=======
/** State: END.
 */
void ec_fsm_slave_config_state_end(
    ec_fsm_slave_config_t *fsm, /**< slave state machine */
    ec_datagram_t *datagram     /**< Datagram to use. */
)
{
}
>>>>>>> Stashed changes
